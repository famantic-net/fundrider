"""
# Synopsis

`python3 interactive_fund_plot.py [--bar] [-t  <directory>]  -r <directory> | :internal:`

Generates interactive fund series charts from CSV files.
Supports:
- Directory mode: Reads all fund_tables_<n>.csv in a directory, outputs individual HTMLs and a master index.
- STDIN mode: Reads a single CSV from stdin if no -t provided, outputs one chart.
- `-r :internal:` mode: Stores HTML in-memory (internal_html) and prints the master HTML to STDOUT.

# Description

Creates interactive fund charts from csv tables generated by `slice_fund_files.pl`.

The charts all converge to value 0 (zero) at the end which is the latest date. The fund data has been normalized for all funds each with respect to the latest date so that it's either higher or lower than zero. This makes comparison between the existing funds very easy. The funds chart series that are placed lower on the chart have had a better increase with respect to the current fund value and oppositely if the fund chart series is graphed higher in the plot with respect to the latest value at the far right it shows the fund losing value.

# Options

- --bar
  Creates a fund performance bar graph displaying which funds that have the best performance depending on a weighted calculation of a number of time windows:

  - week
  - two seek
  - month
  - quarter
  - half year
  - year
  - two years

  The weights can be adjusted interactively.

- -r
  Specifies directory where to store the fund charts, unless the word '`:internal:`' is given. If `-r` is omitted the fund charts will be written to the current directory.
  If '`:internal:`' is given no individual fund charts will be written and the aggregated html containing all charts will be printed on STDOUT. See examples below.
- -t
  Specifies the directory where the csv fund tables that were generated by `slice_fond_files.pl` are located. The csv fund tables are expected to have names as '`fund_tables_<number>.csv'`. This is how the names will be created by the analysis part '`slice_fond_files.pl`'.
  If `-t` is omitted, input is expected on STDIN in the same format as the the csv fund tables. Only one csv table is expected when receiving from STDIN. If a directory is given with `-r` the result will be written to the file '`fund_series_chart.html`'. If `-r :internal:` is given the output will to STDOUT. See examples below.

# Examples

- Read all csv tables in directory '`../tables`' named ' `fund_tables_<number>.csv'` and create a fund chart for each table in directory '`../results`'. Charts will be named '`fund_series_chart_<number>.html`'.

  `python3 interactive_fund_plot.py -t ../tables -r ../results`

- Read all csv tables in directory '`../tables`' named ' `fund_tables_<number>.csv`' and print to STDOUT.

  `python3 interactive_fund_plot.py -t ../tables -r :internal:`

- Same as previous but rediect STDOUT to '`../results/fund_series_charts.stdout.html`'.

  `python3 interactive_fund_plot.py -t ../tables -r :internal: > ../results/fund_series_charts.stdout.html`

- Take input from STDIN and write from STDOUT to '`../results/fund_series_chart.stdout.html`'.

  `cat ../tables/fund_tables_5.csv | python3 interactive_fund_plot.py -r :internal: > ../results/fund_series_chart.stdout.html`

- Take input from STDIN and write from result chart to directory '`../results`' in file '`fund_series_chart.html`'.

  `cat ../tables/fund_tables_5.csv | python3 interactive_fund_plot.py -r ../results`

- Create fund performance chart and print on STDOUT

  `python3 bin/interactive_fund_plot.py --bar -t tables -r :internal: > results/fund_series_scores.stdout.html
"""

import os
import re
import sys
import argparse
import json
import numpy as np
import pandas as pd
import plotly.graph_objs as go

# Parse command-line arguments
parser = argparse.ArgumentParser(
    description='Generate fund series charts from CSVs; supports time-series, bar-score mode, and stdin.'
)
parser.add_argument(
    '-t', dest='input_dir', default='.',
    help='Directory containing fund_tables_<n>.csv'
)
parser.add_argument(
    '-r', dest='output_dir', default='.',
    help='Directory to save HTML or ":internal:" to output HTML to stdout'
)
parser.add_argument(
    '--bar', dest='bar_mode', action='store_true',
    help='Generate performance bar chart instead of time-series'
)
args = parser.parse_args()

# Determine modes
internal_only = (args.output_dir == ':internal:')
use_stdin = (args.input_dir == '.' and not sys.stdin.isatty())
if not internal_only and not use_stdin:
    os.makedirs(args.output_dir, exist_ok=True)

# Common pandas CSV options
df_kwargs = dict(
    sep=';', decimal=',', skiprows=2, header=0,
    parse_dates=[0], dayfirst=True, na_values=[''], encoding='latin1'
)

# JS snippet for hover interactions (for time-series charts)
hover_js = '''<script>
(function() {
  document.querySelectorAll('.plotly-graph-div').forEach(function(gd) {
    // Trace hover
    gd.on('plotly_hover', function(data) {
      var ci = data.points[0].curveNumber;
      // Bold legend entry by index
      var legendTexts = gd.querySelectorAll('.legendtext');
      if (gd.data[ci] && legendTexts.length > ci) {
        var traceName = gd.data[ci].name; // Get name from trace data
        // Attempt to bold by matching name, then fall back to index if needed
        var foundMatchByName = false;
        legendTexts.forEach(el => {
          if(el.textContent.startsWith(traceName.split('<br>')[0])) { // Match primary name part if <br> is used
            el.style.fontWeight='bold';
            foundMatchByName = true;
          }
        });
        if (!foundMatchByName && legendTexts[ci]) {
             legendTexts[ci].style.fontWeight = 'bold';
        }
      } else if (legendTexts.length > ci && legendTexts[ci]) {
         legendTexts[ci].style.fontWeight = 'bold'; // Fallback if gd.data[ci] is undefined
      }
      // Thicken hovered line
      Plotly.restyle(gd, {'line.width':3}, [ci]);
    });
    gd.on('plotly_unhover', function() {
      // Reset legend text
      var texts = gd.querySelectorAll('.legendtext');
      texts.forEach(el => el.style.fontWeight = 'normal');
      // Reset all lines
      Plotly.restyle(gd, {'line.width':2}, Array.from({length:gd.data.length}, (_,j) => j));
    });
    // Legend hover
    function bindLegendHover() {
      var texts = gd.querySelectorAll('.legendtext');
      texts.forEach(function(el, i) {
        el.onmouseenter = function() {
          el.style.fontWeight = 'bold';
          Plotly.restyle(gd, {'line.width':3}, [i]);
        };
        el.onmouseleave = function() {
          el.style.fontWeight = 'normal';
          Plotly.restyle(gd, {'line.width':2}, Array.from({length:gd.data.length}, (_,j) => j));
        };
      });
    }
    gd.on('plotly_afterplot', bindLegendHover);
    gd.on('plotly_legendclick', function() { setTimeout(bindLegendHover, 0); });
  });
})();
</script>'''

# Helper: build HTML for time-series chart
def df_to_html(df, title=None, last_dates=None):
    num_series = len(df.columns) - 1 if 'Date' in df.columns else len(df.columns)
    base_h = max(500, num_series*25 + 100)
    height_px = int(base_h * 1.5)
    fig = go.Figure()
    for col in df.columns:
        if col=='Date': continue
        name = col
        if last_dates and col in last_dates:
            name = f"{col}<br>{last_dates[col]}"
        # Ensure data is numeric before potential exponentiation
        series_data = pd.to_numeric(df[col], errors='coerce')
        perc = (10 ** series_data).round(6) * 100 # Example transformation

        fig.add_trace(go.Scatter(
            x=df['Date'], y=series_data, mode='lines', name=name, customdata=perc,
            line=dict(width=2), hovertemplate=(
                '<b>Series:</b> %{fullData.name}<br>'
                '<b>Date:</b> %{x|%Y-%m-%d}<br>'
                '<b>Value:</b> %{y:.3f} (%{customdata:.1f}%)<extra></extra>'
            )
        ))
    layout = dict(hovermode='closest', template='plotly_white', height=height_px,
                  yaxis=dict(zeroline=True, zerolinewidth=3, title='Value'),
                  xaxis=dict(title='Date'),
                  legend=dict(traceorder='normal'))
    if title: layout['title'] = dict(text=title, x=0.5, xanchor='center')
    fig.update_layout(**layout)
    html = fig.to_html(include_plotlyjs='cdn', full_html=True)
    if '</body>' in html:
        html = html.replace('</body>', hover_js + '\n</body>')
    else:
        html += hover_js
    return html

# Bar-chart mode function
def bar_chart_mode(input_dir, output_dir, internal):
    import os, re, json, numpy as np, pandas as pd, plotly.graph_objs as go
    windows = [7,14,30,90,180,365,730]
    init_weights = [0.3, 1.5, 2.5, 4, 3, 2, 1]

    pat = re.compile(r'fund_tables_(\d+)\.csv$')
    funds, data = [], []
    # Ensure input_dir exists before listing files
    if not os.path.isdir(input_dir):
        print(f"Error: Input directory '{input_dir}' not found.", file=sys.stderr)
        sys.exit(1)

    for fname in sorted(f for f in os.listdir(input_dir) if pat.match(f)):
        try:
            df_temp = pd.read_csv(os.path.join(input_dir, fname), **df_kwargs)
            if df_temp.empty:
                print(f"Warning: CSV file {fname} is empty or has no data after skiprows. Skipping.", file=sys.stderr)
                continue
            df_temp.rename(columns={df_temp.columns[0]: 'Date'}, inplace=True)
            df_temp.set_index('Date', inplace=True)

            for col in df_temp.columns:
                if col.startswith('Unnamed:'): # Skip unnamed columns earlier
                    continue
                ys = pd.to_numeric(df_temp[col], errors='coerce').dropna().values
                if len(ys) == 0: # Skip if column becomes empty after coerce/dropna
                    continue
                pct = []
                for w in windows:
                    if len(ys) < w:
                        pct.append(0)
                    else:
                        m, _ = np.polyfit(np.arange(w), ys[-w:], 1)
                        pct.append(m * (w - 1) * 100)
                funds.append(col)
                data.append(pct)
        except Exception as e:
            print(f"Error processing file {fname}: {e}", file=sys.stderr)
            continue

    if not funds:
        print(f"No valid fund data collected from {input_dir}. Exiting bar chart mode.", file=sys.stderr)
        return # Use return instead of sys.exit(1) if called as a function

    scores = [sum(p * w for p,w in zip(row, init_weights)) for row in data]
    dropdown_funds = sorted([f for f in funds if not f.startswith('Unnamed:')]) # Already filtered in loop, but good for safety

    fig = go.Figure(go.Bar(x=funds, y=scores, marker_color='steelblue', name='Fund Scores')) # x should be all original funds for initial plot
    fig.update_layout(
        title='Current fund performance', template='plotly_white', height=600,
        xaxis=dict(showticklabels=False, title='Funds (Scroll/Isolate to see names)'),
        yaxis=dict(title='Score'), barmode='group'
    )
    fig_dict = fig.to_dict()
    fig_json = json.dumps(fig_dict)
    body = (
        '<div id="bar-chart" style="width:100%; height:600px; margin-bottom:30px;"></div>'
        '<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>'
        f'<script>var figDataInit={fig_json};Plotly.newPlot("bar-chart",figDataInit.data,figDataInit.layout);</script>'
    )

    slider_html = '<table style="margin:auto; width:80%; border-spacing: 10px;"><tr>'
    for i, w in enumerate(windows):
        slider_html += (
            '<td style="text-align:center; padding:10px; vertical-align:top; border: 1px solid #ddd; border-radius: 5px;">'
            f'<div>Window {w}d Weight</div>'
            f'<div><span id="v{i}" style="font-weight:bold;">{init_weights[i]:.1f}</span></div>'
            # Added data-index attribute to easily identify slider index in JS
            f'<div><input id="w{i}" data-index="{i}" type="range" min="0" max="10" step="0.1" '
            f'value="{init_weights[i]:.1f}" style="width:100%;"></div></td>'
        )
    slider_html += '</tr></table>'

    select_html = (
        '<div style="text-align:center; margin:20px 0;">'
        f'<select id="fund-select" multiple size="{min(len(dropdown_funds), 10)}" '
        'style="width:300px; height:200px; overflow-y:auto; border: 1px solid #ccc; border-radius: 5px; padding: 5px;"></select><br/>'
        '<button id="isolate" style="margin:10px 5px; padding: 8px 15px; border-radius:5px; background-color:#4CAF50; color:white; border:none; cursor:pointer;">Isolate</button>'
        '<button id="reset" style="margin:10px 5px; padding: 8px 15px; border-radius:5px; background-color:#f44336; color:white; border:none; cursor:pointer;">Reset</button>'
        '</div>'
    )

    # MODIFIED post_js to include scroll wheel functionality for sliders
    post_js = f"""
<script>
  const percDataForPostJs = {json.dumps(data)};
  const weightInputsForPostJs = Array.from(document.querySelectorAll('input[id^="w"]'));

  function updateScoresOnWeightChange() {{
    const currentWeights = weightInputsForPostJs.map(el => parseFloat(el.value));
    // Update displayed weight values
    currentWeights.forEach((val,i) => {{
        const vElement = document.getElementById('v'+i);
        if (vElement) {{ // Check if element exists
            vElement.textContent = val.toFixed(1);
        }}
    }});
    const newYScores = percDataForPostJs.map(fundPerformanceRow =>
      fundPerformanceRow.reduce((scoreSum, perfPoint, i) => scoreSum + perfPoint * currentWeights[i], 0)
    );
    Plotly.restyle('bar-chart', 'y', [newYScores]);
  }}

  weightInputsForPostJs.forEach(slider => {{
    // Event listener for 'input' (when slider is dragged)
    slider.addEventListener('input', updateScoresOnWeightChange);

    // Event listener for 'wheel' (mouse scroll)
    slider.addEventListener('wheel', function(event) {{
      event.preventDefault(); // Prevent page scrolling

      const step = parseFloat(slider.step) || 0.1; // Get step from slider attribute, default to 0.1
      let currentValue = parseFloat(slider.value);
      const minVal = parseFloat(slider.min) || 0;
      const maxVal = parseFloat(slider.max) || 10;

      if (event.deltaY < 0) {{ // Wheel up
        currentValue += step;
      }} else {{ // Wheel down
        currentValue -= step;
      }}

      // Clamp value to min/max
      currentValue = Math.max(minVal, Math.min(maxVal, currentValue));

      slider.value = currentValue.toFixed(1); // Update slider value (toFixed for precision matching step)

      // Manually trigger the update function since 'input' event doesn't fire on programmatic change
      updateScoresOnWeightChange();
    }});
  }});
  // Initial call to set scores based on initial weights if needed (Plotly.newPlot should handle this)
  // updateScoresOnWeightChange();
</script>
"""
    isolate_js = f"""
<script>
  const allOriginalFunds = {json.dumps(funds)};
  const fundsForDropdown = {json.dumps(dropdown_funds)};
  const percData = {json.dumps(data)}; // This is percDataForIsolateJs, distinct from percDataForPostJs if they were in different scopes
                                       // In this combined script, it's fine, but good to be mindful.

  const fundSelectElement = document.getElementById('fund-select');
  // Note: weightInputs is already defined in post_js. If these scripts were truly separate,
  // you'd redefine it here. Since they are concatenated, it's accessible.
  // const weightInputsForIsolate = Array.from(document.querySelectorAll('input[id^="w"]'));

  fundsForDropdown.forEach(fundName => {{
    const optionElement = document.createElement('option');
    optionElement.value = fundName;
    optionElement.text = fundName;
    fundSelectElement.appendChild(optionElement);
  }});

  function calculateAllCurrentScores() {{
    // Use weightInputsForPostJs as it's the one tied to the event listeners for updates
    const currentWeights = weightInputsForPostJs.map(el => parseFloat(el.value));
    return percData.map(fundPerformanceRow =>
      fundPerformanceRow.reduce((scoreSum, perfPoint, i) => scoreSum + perfPoint * currentWeights[i], 0)
    );
  }}

  document.getElementById('isolate').addEventListener('click', function() {{
    const selectedFundNames = Array.from(fundSelectElement.selectedOptions).map(opt => opt.value);
    if (selectedFundNames.length === 0) {{ return; }}
    const allCurrentScores = calculateAllCurrentScores();
    const indicesInOriginalList = selectedFundNames.map(name => allOriginalFunds.indexOf(name)).filter(index => index !== -1); // Filter out -1 if a name isn't found
    const isolatedXValues = selectedFundNames.filter(name => allOriginalFunds.includes(name)); // Ensure names are valid
    const isolatedYValues = indicesInOriginalList.map(index => allCurrentScores[index]);
    Plotly.restyle('bar-chart', {{ 'x': [isolatedXValues], 'y': [isolatedYValues] }});
  }});

  document.getElementById('reset').addEventListener('click', function() {{
    fundSelectElement.selectedIndex = -1;
    const allCurrentScores = calculateAllCurrentScores();
    Plotly.restyle('bar-chart', {{ 'x': [allOriginalFunds], 'y': [allCurrentScores] }});
  }});
</script>
"""
    full_html = (
        '<!DOCTYPE html><html><head><meta charset="utf-8"><title>Fund Scores</title>'
        '<style>body {{ font-family: Arial, sans-serif; }}</style></head><body>'
        '<h1 style="text-align:center; color:#333;">Fund Performance Dashboard</h1>'
        '<h3 style="text-align:center; color:#555;">Adjust Scoring Weights</h3>'
        + slider_html
        + '<h3 style="text-align:center; margin-top:30px; color:#555;">Fund Scores Bar Chart</h3>'
        + body
        + '<div style="clear:both; margin-top:20px;"></div>'
        + '<h3 style="text-align:center; color:#555;">Isolate Funds</h3>'
        + select_html
        + post_js
        + isolate_js
        + '</body></html>'
    )
    if internal:
        print(full_html)
    else:
        out = os.path.join(output_dir, 'fund_series_scores.html')
        with open(out, 'w', encoding='utf-8') as f:
            f.write(full_html)
        print(f"Saved score chart to {out}", file=sys.stderr)

# STDIN single time-series
if use_stdin and not args.bar_mode:
    try:
        df0 = pd.read_csv(sys.stdin, **df_kwargs)
    except Exception as e:
        print(f"Error reading from stdin: {e}", file=sys.stderr)
        sys.exit(1)

    if df0.empty:
        print("Received empty or all-NA data from stdin after skiprows.", file=sys.stderr)
        sys.exit(1)

    df0.rename(columns={df0.columns[0]:'Date'}, inplace=True)
    df0.dropna(axis=1, how='all', inplace=True)
    df0.dropna(subset=['Date'], how='all', inplace=True) # Drop rows where 'Date' itself is NA
    if df0.empty:
        print("Data became empty after initial NA handling from stdin.", file=sys.stderr)
        sys.exit(1)
    df0.set_index('Date', inplace=True)

    df0 = df0.dropna(axis=1, how='all')
    if df0.empty:
        print("No valid data series found after initial processing from stdin.", file=sys.stderr)
        sys.exit(1)

    last_dates={c:df0[c].last_valid_index().strftime('%Y-%m-%d') for c in df0.columns if pd.notna(df0[c].last_valid_index())}

    if not df0.index.is_monotonic_increasing:
        df0 = df0.sort_index()

    df0.index = pd.to_datetime(df0.index, errors='coerce')
    df0 = df0[pd.notna(df0.index)] # Remove rows where date conversion failed

    if df0.empty:
        print("No valid dates found in stdin data after conversion.", file=sys.stderr)
        sys.exit(1)

    min_date, max_date = df0.index.min(), df0.index.max()
    if pd.isna(min_date) or pd.isna(max_date):
        print("Could not determine a valid date range from stdin data.", file=sys.stderr)
        sys.exit(1)

    idx=pd.date_range(min_date, max_date, freq='D')
    df=df0.reindex(idx).interpolate(method='time').reset_index()
    # The 'Date' column is created by reset_index from the named index 'Date'.
    # If the index was named 'index', it would be 'index', then the original rename would apply.
    # Since we set index to 'Date', it should be 'Date'.
    if 'index' in df.columns and 'Date' not in df.columns: # Safety for unnamed index case
        df.rename(columns={'index':'Date'}, inplace=True)

    if 'Date' in df.columns:
        date_column_data = df['Date']
        other_columns_df = df.drop(columns=['Date'])
        cleaned_other_columns_df = other_columns_df.dropna(axis=1, how='all')
        df = pd.concat([date_column_data, cleaned_other_columns_df], axis=1)

        if len(df.columns) <= 1 : # Only 'Date' column left
            print("No valid data series to plot after interpolation and cleaning from stdin (only Date column).", file=sys.stderr)
            sys.exit(1)
    else:
        print("Critical: 'Date' column missing after processing stdin. Cannot proceed.", file=sys.stderr)
        sys.exit(1)

    html=df_to_html(df,title='Fund Series Chart (from stdin)',last_dates=last_dates)
    if internal_only:
        print(html)
    else:
        outf=os.path.join(args.output_dir,'fund_series_chart_stdin.html')
        with open(outf,'w',encoding='utf-8') as f: f.write(html)
        print(f"Saved {outf}",file=sys.stderr)
    sys.exit(0)

# Bar-mode
if args.bar_mode:
    if use_stdin:
        print("Bar mode cannot be used with stdin input. Please provide an input directory with -t.", file=sys.stderr)
        sys.exit(1)
    bar_chart_mode(args.input_dir,args.output_dir,internal_only)
    sys.exit(0)

# Directory time-series
pat=re.compile(r'fund_tables_(\d+)\.csv$')
csv_files = []
if os.path.isdir(args.input_dir):
    csv_files = sorted(
        (int(m.group(1)), os.path.join(args.input_dir, f))
        for f in os.listdir(args.input_dir)
        for m in [pat.match(f)] if m
    )
else: # Handle case where input_dir is not a directory
    if not (use_stdin or args.bar_mode): # if not other modes, then this is an error
        print(f"Error: Input directory '{args.input_dir}' not found or is not a directory.", file=sys.stderr)
        sys.exit(1)


if not csv_files and not (use_stdin or args.bar_mode): # Check only if this mode is active
    print(f"No CSVs matching 'fund_tables_<n>.csv' found in {args.input_dir}", file=sys.stderr)
    sys.exit(1)

htmls=[]
internal_html={}
for idx_num, filepath in csv_files:
    try:
        df0=pd.read_csv(filepath,**df_kwargs)
    except Exception as e:
        print(f"Error reading CSV file {filepath}: {e}", file=sys.stderr)
        continue # Skip to next file

    if df0.empty:
        print(f"Warning: CSV file {filepath} is empty or has no data after skiprows. Skipping.", file=sys.stderr)
        continue

    df0.rename(columns={df0.columns[0]:'Date'},inplace=True)
    df0.dropna(axis=1,how='all',inplace=True)
    df0.dropna(subset=['Date'], how='all', inplace=True) # Drop rows where 'Date' itself is NA
    if df0.empty:
        print(f"Data became empty for {filepath} after initial NA handling.", file=sys.stderr)
        continue
    df0.set_index('Date',inplace=True)

    df0 = df0.dropna(axis=1, how='all') # Drop series that are entirely NA
    if df0.empty:
        print(f"No valid data series in {filepath} after initial processing.", file=sys.stderr)
        continue

    last_dates={c:df0[c].last_valid_index().strftime('%Y-%m-%d') for c in df0.columns if pd.notna(df0[c].last_valid_index())}

    if not df0.index.is_monotonic_increasing:
        df0 = df0.sort_index()

    df0.index = pd.to_datetime(df0.index, errors='coerce')
    df0 = df0[pd.notna(df0.index)] # Remove rows where date conversion failed

    if df0.empty:
        print(f"No valid dates in {filepath} after conversion. Skipping.", file=sys.stderr)
        continue

    min_date, max_date = df0.index.min(), df0.index.max()
    if pd.isna(min_date) or pd.isna(max_date):
        print(f"Could not determine a valid date range from {filepath}. Skipping.", file=sys.stderr)
        continue

    idxr=pd.date_range(min_date,max_date,freq='D')
    df=df0.reindex(idxr).interpolate(method='time').reset_index()
    # The 'Date' column is created by reset_index from the named index 'Date'.
    if 'index' in df.columns and 'Date' not in df.columns: # Safety for unnamed index case
        df.rename(columns={'index':'Date'}, inplace=True)

    # Remove columns (except 'Date') that are still all NaN after interpolation
    if 'Date' in df.columns:
        date_column_data = df['Date']
        other_columns_df = df.drop(columns=['Date'])
        cleaned_other_columns_df = other_columns_df.dropna(axis=1, how='all')
        df = pd.concat([date_column_data, cleaned_other_columns_df], axis=1)

        if len(df.columns) <= 1: # Only 'Date' column (or fewer)
            print(f"No valid data series to plot in {filepath} after interpolation and cleaning (only Date column or empty).", file=sys.stderr)
            continue
    else:
        print(f"Warning: 'Date' column not found in DataFrame for {filepath} after reset_index. Skipping this file.", file=sys.stderr)
        continue

    html=df_to_html(df,title=f'Fund Series Chart {idx_num}',last_dates=last_dates)
    if internal_only:
        internal_html[idx_num]=html; print(f"Stored chart {idx_num} internally",file=sys.stderr)
    else:
        name=f'fund_series_chart_{idx_num}.html'
        p=os.path.join(args.output_dir,name)
        with open(p,'w',encoding='utf-8') as ff: ff.write(html)
        print(f"Saved {p}"); htmls.append(name)

if not (use_stdin or args.bar_mode) and not htmls and not internal_html : # Check only if this mode was active
    print("No charts were generated from directory processing.", file=sys.stderr)
    # sys.exit(1) # Avoid exiting if other modes might have run or if this is not critical

# Master index (only if not in stdin mode or bar_mode, as they handle their own output/exit)
if not use_stdin and not args.bar_mode and (htmls or internal_html):
    base=['</body>','</html>']
    lines=['<!DOCTYPE html>','<html lang="en">','<head>','  <meta charset="utf-8">',
           '  <meta name="viewport" content="width=device-width, initial-scale=1">',
           '  <title>Aggregated Fund Series Charts</title>',
           '  <style>body { font-family: Arial, sans-serif; margin: 0; padding: 0; background-color: #f4f4f4; } iframe { border: 1px solid #ccc; margin-bottom: 10px; } hr { display: none; }</style>',
           '</head>','<body>']
    lines.append('<h1 style="text-align:center; margin-top:20px; margin-bottom:20px;">Aggregated Fund Series Charts</h1>')

    if internal_only:
        for idx_num in sorted(internal_html.keys()):
            c=internal_html[idx_num].replace('"','&quot;')
            lines.append(f'<iframe title="Fund Series Chart {idx_num}" srcdoc="{c}" style="width:100%; height:850px; border:none;"></iframe>')
        print("\n".join(lines+base))
    else:
        for name in htmls:
            lines.append(f'<iframe title="{name}" src="{name}" style="width:100%; height:850px; border:none;"></iframe>')
        lines+=base
        idxp=os.path.join(args.output_dir,'fund_series_charts_index.html')
        with open(idxp,'w',encoding='utf-8') as f:f.write("\n".join(lines))
        print(f"Generated index at {idxp}")
elif not use_stdin and not args.bar_mode:
    print("No charts to include in master index.", file=sys.stderr)

