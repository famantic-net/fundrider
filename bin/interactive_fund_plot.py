"""
# Synopsis

`python3 interactive_fund_plot.py [--bar] [-t  <directory>]  -r <directory> | :internal:`

Generates interactive fund series charts from CSV files.
Supports:
- Directory mode: Reads all fund_tables_<n>.csv in a directory, outputs individual HTMLs and a master index.
- STDIN mode: Reads a single CSV from stdin if no -t provided, outputs one chart.
- `-r :internal:` mode: Stores HTML in-memory (internal_html) and prints the master HTML to STDOUT.

# Description

Creates interactive fund charts from csv tables generated by `slice_fund_files.pl`.

The charts all converge to value 0 (zero) at the end which is the latest date. The fund data has been normalized for all funds each with respect to the latest date so that it's either higher or lower than zero. This makes comparison between the existing funds very easy. The funds chart series that are placed lower on the chart have had a better increase with respect to the current fund value and oppositely if the fund chart series is graphed higher in the plot with respect to the latest value at the far right it shows the fund losing value.

# Options

- --bar
  Creates a fund performance bar graph displaying which funds that have the best performance depending on a weighted calculation of a number of time windows:

  - week
  - two seek
  - month
  - quarter
  - half year
  - year
  - two years

  The weights can be adjusted interactively.

- -r
  Specifies directory where to store the fund charts, unless the word '`:internal:`' is given. If `-r` is omitted the fund charts will be written to the current directory.
  If '`:internal:`' is given no individual fund charts will be written and the aggregated html containing all charts will be printed on STDOUT. See examples below.
- -t
  Specifies the directory where the csv fund tables that were generated by `slice_fond_files.pl` are located. The csv fund tables are expected to have names as '`fund_tables_<number>.csv'`. This is how the names will be created by the analysis part '`slice_fond_files.pl`'.
  If `-t` is omitted, input is expected on STDIN in the same format as the the csv fund tables. Only one csv table is expected when receiving from STDIN. If a directory is given with `-r` the result will be written to the file '`fund_series_chart.html`'. If `-r :internal:` is given the output will to STDOUT. See examples below.

# Examples

- Read all csv tables in directory '`../tables`' named ' `fund_tables_<number>.csv'` and create a fund chart for each table in directory '`../results`'. Charts will be named '`fund_series_chart_<number>.html`'.

  `python3 interactive_fund_plot.py -t ../tables -r ../results`

- Read all csv tables in directory '`../tables`' named ' `fund_tables_<number>.csv`' and print to STDOUT.

  `python3 interactive_fund_plot.py -t ../tables -r :internal:`

- Same as previous but rediect STDOUT to '`../results/fund_series_charts.stdout.html`'.

  `python3 interactive_fund_plot.py -t ../tables -r :internal: > ../results/fund_series_charts.stdout.html`

- Take input from STDIN and write from STDOUT to '`../results/fund_series_chart.stdout.html`'.

  `cat ../tables/fund_tables_5.csv | python3 interactive_fund_plot.py -r :internal: > ../results/fund_series_chart.stdout.html`

- Take input from STDIN and write from result chart to directory '`../results`' in file '`fund_series_chart.html`'.

  `cat ../tables/fund_tables_5.csv | python3 interactive_fund_plot.py -r ../results`

- Create fund performance chart and print on STDOUT

  `python3 bin/interactive_fund_plot.py --bar -t tables -r :internal: > results/fund_series_scores.stdout.html
"""

import os
import re
import sys
import argparse
import json
import numpy as np
import pandas as pd
import plotly.graph_objs as go

# Parse command-line arguments
parser = argparse.ArgumentParser(
    description='Generate fund series charts from CSVs; supports time-series, bar-score mode, and stdin.'
)
parser.add_argument(
    '-t', dest='input_dir', default='.',
    help='Directory containing fund_tables_<n>.csv'
)
parser.add_argument(
    '-r', dest='output_dir', default='.',
    help='Directory to save HTML or ":internal:" to output HTML to stdout'
)
parser.add_argument(
    '--bar', dest='bar_mode', action='store_true',
    help='Generate performance bar chart instead of time-series'
)
args = parser.parse_args()

# Determine modes
internal_only = (args.output_dir == ':internal:')
use_stdin = (args.input_dir == '.' and not sys.stdin.isatty())
if not internal_only and not use_stdin:
    os.makedirs(args.output_dir, exist_ok=True)

# Common pandas CSV options
df_kwargs = dict(
    sep=';', decimal=',', skiprows=2, header=0,
    parse_dates=[0], dayfirst=True, na_values=[''], encoding='latin1'
)

# JS snippet for hover interactions
hover_js = '''<script>
(function() {
  document.querySelectorAll('.plotly-graph-div').forEach(function(gd) {
    // Trace hover
    gd.on('plotly_hover', function(data) {
      var ci = data.points[0].curveNumber;
      // Bold legend entry by index
      var texts = gd.querySelectorAll('.legendtext');
      if(texts[ci]) texts[ci].style.fontWeight = 'bold';
      // Thicken hovered line
      Plotly.restyle(gd, {'line.width':3}, [ci]);
    });
    gd.on('plotly_unhover', function() {
      // Reset legend text
      var texts = gd.querySelectorAll('.legendtext');
      texts.forEach(el => el.style.fontWeight = 'normal');
      // Reset all lines
      Plotly.restyle(gd, {'line.width':2}, Array.from({length:gd.data.length}, (_,j) => j));
    });
    // Legend hover
    function bindLegendHover() {
      var texts = gd.querySelectorAll('.legendtext');
      texts.forEach(function(el, i) {
        el.onmouseenter = function() {
          el.style.fontWeight = 'bold';
          Plotly.restyle(gd, {'line.width':3}, [i]);
        };
        el.onmouseleave = function() {
          el.style.fontWeight = 'normal';
          Plotly.restyle(gd, {'line.width':2}, Array.from({length:gd.data.length}, (_,j) => j));
        };
      });
    }
    gd.on('plotly_afterplot', bindLegendHover);
    gd.on('plotly_legendclick', function() { setTimeout(bindLegendHover, 0); });
  });
})();
</script>'''

# Helper: build HTML for time-series chart
def df_to_html(df, title=None, last_dates=None):
    # dynamic height
    num_series = len(df.columns) - 1
    base_h = max(500, num_series*25 + 100)
    height_px = int(base_h * 1.5)
    fig = go.Figure()
    for col in df.columns:
        if col=='Date': continue
        name = col
        if last_dates and col in last_dates:
            name = f"{col}<br>{last_dates[col]}"
        perc = (10 ** df[col]).round(6) * 100
        fig.add_trace(go.Scatter(
            x=df['Date'], y=df[col], mode='lines', name=name, customdata=perc,
            line=dict(width=2), hovertemplate=(
                '<b>Series:</b> %{fullData.name}<br>'
                '<b>Date:</b> %{x|%Y-%m-%d}<br>'
                '<b>Value:</b> %{y:.3f} (%{customdata:.1f}%)<extra></extra>'
            )
        ))
    layout = dict(hovermode='closest', template='plotly_white', height=height_px,
                  yaxis=dict(zeroline=True, zerolinewidth=3))
    if title: layout['title'] = title
    fig.update_layout(**layout)
    html = fig.to_html(include_plotlyjs='cdn', full_html=True)
    return html.replace('</body>', hover_js + '\n</body>')

# Bar-chart mode function
def bar_chart_mode(input_dir, output_dir, internal):
    import os, re, json, numpy as np, pandas as pd, plotly.graph_objs as go
    windows = [7,14,30,90,180,365,730]
    init_weights = [0.3, 1.5, 2.5, 4, 3, 2, 1]

    # 1) Collect percent-change series
    pat = re.compile(r'fund_tables_(\d+)\.csv$')
    funds, data = [], []
    for fname in sorted(f for f in os.listdir(input_dir) if pat.match(f)):
        df = pd.read_csv(os.path.join(input_dir, fname), **df_kwargs)
        df.rename(columns={df.columns[0]: 'Date'}, inplace=True)
        df.set_index('Date', inplace=True)
        for col in df.columns:
            ys = df[col].dropna().values
            pct = []
            for w in windows:
                if len(ys) < w:
                    pct.append(0)
                else:
                    m, _ = np.polyfit(np.arange(w), ys[-w:], 1)
                    pct.append(m * (w - 1) * 100)
            funds.append(col)
            data.append(pct)

        # 2) Build initial bar chart
    scores = [sum(p * w for p,w in zip(row, init_weights)) for row in data]
    fig = go.Figure(go.Bar(x=funds, y=scores, marker_color='steelblue'))
    fig.update_layout(
        title='Current fund performance',
        template='plotly_white',
        height=600,
        xaxis=dict(showticklabels=False),
        yaxis=dict(title='score')
    )
    # Render chart via Plotly.newPlot for predictable div id
    fig_dict = fig.to_dict()
    fig_json = json.dumps(fig_dict)
    body = (
        '<div id="bar-chart" style="width:100%; height:500px;"></div>'
        '<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>'
        f'<script>var fig={fig_json};Plotly.newPlot("bar-chart",fig.data,fig.layout);</script>'
    )

    # 3) Build sliders in table cells for horizontal arrangement
    slider_html = '<table style="margin:auto;"><tr>'
    for i, w in enumerate(windows):
        slider_html += (
            '<td style="text-align:center; padding:10px; vertical-align:top;">'
            f'<div>Window {w}d Weight</div>'
            f'<div><span id="v{i}">{init_weights[i]:.1f}</span></div>'
            f'<div><input id="w{i}" type="range" min=\"0\" max=\"10\" step="0.1" '
            f'value="{init_weights[i]:.1f}"></div>'
            '</td>'
        )
    slider_html += '</tr></table>'

        # 4) JavaScript for live re-scoring
    post_js = f"""
<script>
  const perc = {json.dumps(data)};
  const inputs = Array.from(document.querySelectorAll('input[id^="w"]'));
  function update() {{
    const ws = inputs.map(el => parseFloat(el.value));
    // update displayed slider values
    ws.forEach((val,i) => {{
      document.getElementById('v'+i).textContent = val.toFixed(1);
    }});
    const newY = perc.map(row => row.reduce((s,p,i) => s + p*ws[i], 0));
    Plotly.restyle('bar-chart', 'y', [newY]);
  }}
  inputs.forEach(el => el.addEventListener('input', update));
  // initialize
  update();
</script>
"""

    # 5) Assemble final HTML
    full_html = (
        '<!DOCTYPE html><html><head><meta charset="utf-8">'
        '<title>Fund Scores</title></head><body>'
        '<h3 style="text-align:center;">Adjust Weights</h3>'
        + slider_html
        + body.replace('<div id="bar-chart"', '<div id="bar-chart" style="width:100%; height:500px;"')
        + post_js
        + '</body></html>'
    )

    # 6) Output
    if internal:
        print(full_html)
    else:
        out = os.path.join(output_dir, 'fund_series_scores.html')
        with open(out, 'w', encoding='utf-8') as f:
            f.write(full_html)
        print(f"Saved score chart to {out}", file=sys.stderr)

# STDIN single time-series
if use_stdin and not args.bar_mode:
    df0 = pd.read_csv(sys.stdin, **df_kwargs)
    df0.rename(columns={df0.columns[0]:'Date'}, inplace=True)
    df0.dropna(axis=1, how='all', inplace=True)
    df0.set_index('Date', inplace=True)
    last_dates={c:df0[c].last_valid_index().strftime('%Y-%m-%d') for c in df0.columns}
    idx=pd.date_range(df0.index.min(),df0.index.max(),freq='D')
    df=df0.reindex(idx).interpolate().reset_index().rename(columns={'index':'Date'})
    html=df_to_html(df,title='Fund Series Chart',last_dates=last_dates)
    if internal_only:
        print(html)
    else:
        outf=os.path.join(args.output_dir,'fund_series_chart.html')
        with open(outf,'w',encoding='utf-8') as f: f.write(html)
        print(f"Saved {outf}",file=sys.stderr)
    sys.exit(0)

# Bar-mode
if args.bar_mode:
    bar_chart_mode(args.input_dir,args.output_dir,internal_only)
    sys.exit(0)

# Directory time-series
pat=re.compile(r'fund_tables_(\d+)\.csv$')
csvs=sorted((int(m.group(1)),f) for f in os.listdir(args.input_dir) for m in [pat.match(f)] if m)
if not csvs: print(f"No CSVs in {args.input_dir}"), sys.exit(1)
htmls=[]
internal_html={}
for idx,f in csvs:
    df0=pd.read_csv(os.path.join(args.input_dir,f),**df_kwargs)
    df0.rename(columns={df0.columns[0]:'Date'},inplace=True)
    df0.dropna(axis=1,how='all',inplace=True)
    df0.set_index('Date',inplace=True)
    last_dates={c:df0[c].last_valid_index().strftime('%Y-%m-%d') for c in df0.columns}
    idxr=pd.date_range(df0.index.min(),df0.index.max(),freq='D')
    df=df0.reindex(idxr).interpolate().reset_index().rename(columns={'index':'Date'})
    html=df_to_html(df,title=f'Fund Series Chart {idx}',last_dates=last_dates)
    if internal_only:
        internal_html[idx]=html; print(f"Stored chart {idx} internally",file=sys.stderr)
    else:
        name=f'fund_series_chart_{idx}.html'
        p=os.path.join(args.output_dir,name)
        with open(p,'w',encoding='utf-8') as ff: ff.write(html)
        print(f"Saved {p}"); htmls.append(name)

# Master index
base=['</body>','</html>']
lines=['<!DOCTYPE html>','<html lang="en">','<head>','  <meta charset="utf-8">',
       '  <meta name="viewport" content="width=device-width, initial-scale=1">',
       '  <title>Aggregated Fund Series Charts</title>','</head>','<body>']
if internal_only:
    for idx,_ in csvs:
        c=internal_html[idx].replace('"','&quot;')
        lines.append(f'<iframe srcdoc="{c}" style="width:100%; height:850px; border:none;"></iframe>')
        lines.append('<hr style="border:none; border-top:3px solid #ccc; margin:20px 0;">')
    print("\n".join(lines+base))
else:
    for name in htmls:
        lines.append(f'<iframe src="{name}" style="width:100%; height:850px; border:none;"></iframe>')
        lines.append('<hr style="border:none; border-top:3px solid #ccc; margin:20px 0;">')
    lines+=base
    idxp=os.path.join(args.output_dir,'fund_series_charts.html')
    with open(idxp,'w',encoding='utf-8') as f:f.write("\n".join(lines))
    print(f"Generated index at {idxp}")
