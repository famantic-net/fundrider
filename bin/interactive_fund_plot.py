"""
# Synopsis

`python3 interactive_fund_plot.py [-t  <directory>]  -r <directory> | :internal:`

Generates interactive fund series charts from CSV files.
Supports:
- Directory mode: Reads all fund_tables_<n>.csv in a directory, outputs individual HTMLs and a master index.
- STDIN mode: Reads a single CSV from stdin if no -t provided, outputs one chart.
- `-r :internal:` mode: Stores HTML in-memory (internal_html) and prints the master HTML to STDOUT.

# Description

Creates interactive fund charts from csv tables generated by `slice_fund_files.pl`.

The charts all converge to value 0 (zero) at the end which is the latest date. The fund data has been normalized for all funds each with respect to the latest date so that it's either higher or lower than zero. This makes comparison between the existing funds very easy. The funds chart series that are placed lower on the chart have had a better increase with respect to the current fund value and oppositely if the fund chart series is graphed higher in the plot with respect to the latest value at the far right it shows the fund losing value.

# Options

- -r
  Specifies directory where to store the fund charts, unless the word '`:internal:`' is given. If `-r` is omitted the fund charts will be written to the current directory.
  If '`:internal:`' is given no individual fund charts will be written and the aggregated html containing all charts will be printed on STDOUT. See examples below.
- -t
  Specifies the directory where the csv fund tables that were generated by `slice_fond_files.pl` are located. The csv fund tables are expected to have names as '`fund_tables_<number>.csv'`. This is how the names will be created by the analysis part '`slice_fond_files.pl`'.
  If `-t` is omitted, input is expected on STDIN in the same format as the the csv fund tables. Only one csv table is expected when receiving from STDIN. If a directory is given with `-r` the result will be written to the file '`fund_series_chart.html`'. If `-r :internal:` is given the output will to STDOUT. See examples below.

# Examples

- Read all csv tables in directory '`../tables`' named ' `fund_tables_<number>.csv'` and create a fund chart for each table in directory '`../results`'. Charts will be named '`fund_series_chart_<number>.html`'.

  `python3 interactive_fund_plot.py -t ../tables -r ../results`

- Read all csv tables in directory '`../tables`' named ' `fund_tables_<number>.csv`' and print to STDOUT.

  `python3 interactive_fund_plot.py -t ../tables -r :internal:`

- Same as previous but rediect STDOUT to '`../results/fund_series_charts.stdout.html`'.

  `python3 interactive_fund_plot.py -t ../tables -r :internal: > ../results/fund_series_charts.stdout.html`

- Take input from STDIN and write from STDOUT to '`../results/fund_series_chart.stdout.html`'.

  `cat ../tables/fund_tables_5.csv | python3 interactive_fund_plot.py -r :internal: > ../results/fund_series_chart.stdout.html`

- Take input from STDIN and write from result chart to directory '`../results`' in file '`fund_series_chart.html`'.

  `cat ../tables/fund_tables_5.csv | python3 interactive_fund_plot.py -r ../results`
"""

import os
import re
import sys
import argparse
import pandas as pd
import plotly.graph_objs as go

# Parse command-line arguments
parser = argparse.ArgumentParser(
    description='Generate fund series charts from CSVs; stdin support for single-table mode.'
)
parser.add_argument(
    '-t', dest='input_dir', default='.',
    help='Directory containing fund_tables_<n>.csv'
)
parser.add_argument(
    '-r', dest='output_dir', default='.',
    help='Directory to save HTML files and index, or use ":internal:" to output index to STDOUT'
)
args = parser.parse_args()

# Determine modes
internal_only = (args.output_dir == ':internal:')
use_stdin = (args.input_dir == '.' and not sys.stdin.isatty())
if not internal_only and not use_stdin:
    os.makedirs(args.output_dir, exist_ok=True)

# JavaScript for hover: thickens line and bolds both trace and legend text
hover_js = '''<script>
(function() {
  document.querySelectorAll('.plotly-graph-div').forEach(function(gd) {
    // Trace hover
    gd.on('plotly_hover', function(data) {
      var name = data.points[0].fullData.name;
      var ci = data.points[0].curveNumber;
      gd.querySelectorAll('.legendtext').forEach(el => { if(el.textContent===name) el.style.fontWeight='bold'; });
      Plotly.restyle(gd, {'line.width':3}, [ci]);
    });
    gd.on('plotly_unhover', function() {
      gd.querySelectorAll('.legendtext').forEach(el => el.style.fontWeight='normal');
      Plotly.restyle(gd, {'line.width':2}, Array.from({length:gd.data.length}, (_,i)=>i));
    });
    // Legend hover (bind after render)
    function bindLegendHover() {
      var texts = gd.querySelectorAll('.legendtext');
      texts.forEach(function(el, i) {
        el.onmouseenter = function() {
          el.style.fontWeight='bold';
          Plotly.restyle(gd, {'line.width':3}, [i]);
        };
        el.onmouseleave = function() {
          el.style.fontWeight='normal';
          Plotly.restyle(gd, {'line.width':2}, Array.from({length:gd.data.length}, (_,j)=>j));
        };
      });
    }
    gd.on('plotly_afterplot', bindLegendHover);
    gd.on('plotly_legendclick', function() { setTimeout(bindLegendHover, 0); });
  });
})();
</script>'''

# Common pandas CSV options
df_kwargs = dict(
    sep=';', decimal=',', skiprows=2, header=0,
    parse_dates=[0], dayfirst=True, na_values=[''], encoding='latin1'
)

# Function to build HTML with optional last-dates in legend, dynamic height for legend
def df_to_html(df, title=None, last_dates=None):
    # Determine number of series for legend height
    num_series = len(df.columns) - 1
    # Approx ~25px per item + padding, then increase by 50%
    base_height = max(500, num_series * 25 + 100)
    height_px = int(base_height * 1.5)

    fig = go.Figure()
    for col in df.columns:
        if col == 'Date': continue
        name = col
        if last_dates and col in last_dates:
            name = f"{col}<br>{last_dates[col]}"
        fig.add_trace(go.Scatter(
            x=df['Date'], y=df[col], mode='lines', name=name,
            line=dict(width=2), hovertemplate=(
                '<b>Series:</b> %{fullData.name}<br>'
                '<b>Date:</b> %{x|%Y-%m-%d}<br>'
                '<b>Value:</b> %{y:.3f}<extra></extra>'
            )
        ))
    # Add zero gridline thicker
    layout = dict(
        hovermode='closest',
        template='plotly_white',
        height=height_px,
        yaxis=dict(zeroline=True, zerolinewidth=3)
    )
    if title:
        layout['title'] = title
    fig.update_layout(**layout)
    html_str = fig.to_html(include_plotlyjs='cdn', full_html=True)
    return html_str.replace('</body>', hover_js + '\n</body>')

# STDIN mode for single CSV
if use_stdin:
    df_raw = pd.read_csv(sys.stdin, **df_kwargs)
    df_raw.rename(columns={df_raw.columns[0]:'Date'}, inplace=True)
    df_raw.dropna(axis=1, how='all', inplace=True)
    df_raw.set_index('Date', inplace=True)
    last_dates = {col: df_raw[col].last_valid_index().strftime('%Y-%m-%d') for col in df_raw.columns}
    full_idx = pd.date_range(df_raw.index.min(), df_raw.index.max(), freq='D')
    df = df_raw.reindex(full_idx).interpolate()
    df.reset_index(inplace=True)
    df.rename(columns={'index':'Date'}, inplace=True)

    html = df_to_html(df, title='Fund Series Chart', last_dates=last_dates)
    if internal_only:
        print(html)
    else:
        out_file = os.path.join(args.output_dir, 'fund_series_chart.html')
        with open(out_file, 'w', encoding='utf-8') as f:
            f.write(html)
        print(f"Saved {out_file}", file=sys.stderr)
    sys.exit(0)

# Directory mode: find and sort CSVs
pat = re.compile(r'fund_tables_(\d+)\.csv$')
csv_files = sorted([(int(m.group(1)), f)
                    for f in os.listdir(args.input_dir)
                    for m in [pat.match(f)] if m], key=lambda x: x[0])
if not csv_files:
    print(f"No CSV files matching 'fund_tables_<n>.csv' in {args.input_dir}")
    sys.exit(1)

# Process each CSV
html_files = []
internal_html = {}
for idx, fname in csv_files:
    path = os.path.join(args.input_dir, fname)
    df_raw = pd.read_csv(path, **df_kwargs)
    df_raw.rename(columns={df_raw.columns[0]:'Date'}, inplace=True)
    df_raw.dropna(axis=1, how='all', inplace=True)
    df_raw.set_index('Date', inplace=True)
    last_dates = {col: df_raw[col].last_valid_index().strftime('%Y-%m-%d') for col in df_raw.columns}
    full_idx = pd.date_range(df_raw.index.min(), df_raw.index.max(), freq='D')
    df = df_raw.reindex(full_idx).interpolate()
    df.reset_index(inplace=True)
    df.rename(columns={'index':'Date'}, inplace=True)

    html = df_to_html(df, title=f'Fund Series Chart {idx}', last_dates=last_dates)
    if internal_only:
        internal_html[idx] = html
        print(f"Stored chart {idx} internally", file=sys.stderr)
    else:
        out_name = f'fund_series_chart_{idx}.html'
        out_path = os.path.join(args.output_dir, out_name)
        with open(out_path, 'w', encoding='utf-8') as f:
            f.write(html)
        print(f"Saved {out_path}")
        html_files.append(out_name)

# Generate master index
lines = ['<!DOCTYPE html>', '<html lang="en">', '<head>',
         '  <meta charset="utf-8">',
         '  <meta name="viewport" content="width=device-width, initial-scale=1">',
         '  <title>Aggregated Fund Series Charts</title>',
         '</head>', '<body>']
if internal_only:
    for idx, _ in csv_files:
        content = internal_html[idx].replace('"','&quot;')
        lines.append(f'<iframe srcdoc="{content}" style="width:100%; height:850px; border:none;"></iframe>')
        lines.append('<hr style="border:none; border-top:3px solid #ccc; margin:20px 0;">')
    print("\n".join(lines + ['</body>', '</html>']))
else:
    for name in html_files:
        lines.append(f'<iframe src="{name}" style="width:100%; height:850px; border:none;"></iframe>')
        lines.append('<hr style="border:none; border-top:3px solid #ccc; margin:20px 0;">')
    lines += ['</body>', '</html>']
    idx_path = os.path.join(args.output_dir, 'fund_series_charts.html')
    with open(idx_path, 'w', encoding='utf-8') as f:
        f.write("\n".join(lines))
    print(f"Generated index at {idx_path}")
